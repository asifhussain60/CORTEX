# CORTEX Tier 0 Governance Rule Optimization for Copilot Efficiency
# Systematic reordering of governance rules for sequential reading optimization
# Version: 1.0.0
# Status: ðŸŽ¯ IMPLEMENTATION READY
# Phase: CORTEX 3.1 Enhancement
# Author: Asif Hussain
# Date: November 16, 2025
# Copyright: Â© 2024-2025 Asif Hussain. All rights reserved.

metadata:
  version: "1.0.0"
  purpose: "Optimize governance.yaml rule ordering for Copilot sequential reading efficiency"
  current_rule_count: 29
  target_optimization: "40-60% reduction in forward-reference lookups"
  rationale: |
    Copilot reads sequentially, so frequently-referenced rules should appear early.
    Current structure organizes by human logic (Quality â†’ Protection â†’ SOLID â†’ etc.)
    but Copilot efficiency requires dependency-first ordering.
  
  principles:
    - "Most-referenced rules first (reduce forward lookups)"
    - "Critical blockers at top (fail-fast validation)"
    - "Dependent rules after dependencies (no circular refs)"
    - "Related rules grouped (better context window utilization)"
    - "Rarely-used rules at end (minimize token waste)"

current_structure_analysis:
  problems:
    rule_ordering:
      - "TEST_FIRST_TDD (Rule 5) references DoD (Rule 20) - forward reference"
      - "BRAIN_PROTECTION (Rule 22) references TIER_BOUNDARIES (Rule 10) - forward reference"
      - "MODULAR_FILE_STRUCTURE (Rule 26) references SINGLE_RESPONSIBILITY (Rule 7) - forward reference"
      - "YAML_BASED_PLANNING (Rule 29) is last but referenced by BRAIN_PROTECTION - far forward reference"
    
    grouping_issues:
      - "Quality rules scattered (Rules 5, 20, 21 not adjacent)"
      - "SOLID rules separated (Rules 7, 8, 9 not adjacent)"
      - "Architecture rules mixed with data rules"
      - "Automation rules interspersed with quality rules"
    
    token_waste:
      - "Copilot loads entire file to find referenced rules"
      - "Every forward reference costs 500-1000 tokens in lookups"
      - "Estimated 15-20 forward references Ã— 750 tokens = 11,250-15,000 wasted tokens per governance read"
  
  dependency_analysis:
    most_referenced_rules:
      - rule: "DEFINITION_OF_DONE"
        id: 20
        current_position: 3
        references_by: ["TEST_FIRST_TDD", "AUTO_GIT_COMMIT", "CHECKPOINT_STRATEGY", "BRAIN_PROTECTION"]
        reference_count: 4
        optimal_position: 1
      
      - rule: "DEFINITION_OF_READY"
        id: 21
        current_position: 4
        references_by: ["TEST_FIRST_TDD", "WORK_PLANNER", "BRAIN_PROTECTION"]
        reference_count: 3
        optimal_position: 2
      
      - rule: "BRAIN_PROTECTION"
        id: 22
        current_position: 5
        references_by: ["CHALLENGE_USER_CHANGES", "TIER_BOUNDARIES", "YAML_BASED_PLANNING"]
        reference_count: 3
        optimal_position: 3
      
      - rule: "SINGLE_RESPONSIBILITY"
        id: 7
        current_position: 7
        references_by: ["MODULAR_FILE_STRUCTURE", "HEMISPHERE_SEPARATION", "PLUGIN_ARCHITECTURE"]
        reference_count: 3
        optimal_position: 6

optimized_structure:
  ordering_principles:
    tier_1_critical_gates:
      position: "1-5"
      rationale: "Most-referenced, blocking rules first"
      rules:
        - id: 20
          name: "DEFINITION_OF_DONE"
          reason: "Referenced by 4+ rules, critical quality gate"
        
        - id: 21
          name: "DEFINITION_OF_READY"
          reason: "Referenced by 3+ rules, entry gate"
        
        - id: 22
          name: "BRAIN_PROTECTION"
          reason: "Referenced by 3+ rules, core protection"
        
        - id: 5
          name: "TEST_FIRST_TDD"
          reason: "Depends on DoD/DoR, core workflow"
        
        - id: 18
          name: "CHALLENGE_USER_CHANGES"
          reason: "Depends on BRAIN_PROTECTION, frequently invoked"
    
    tier_2_architecture_foundations:
      position: "6-12"
      rationale: "SOLID + Design patterns (referenced by implementation rules)"
      rules:
        - id: 7
          name: "SINGLE_RESPONSIBILITY"
          reason: "Core SOLID principle, referenced by 3+ rules"
        
        - id: 8
          name: "INTERFACE_SEGREGATION"
          reason: "SOLID principle, referenced by agent design"
        
        - id: 9
          name: "DEPENDENCY_INVERSION"
          reason: "SOLID principle, referenced by plugin architecture"
        
        - id: 25
          name: "INDUSTRY_STANDARD_PATTERNS"
          reason: "Design patterns foundation, referenced by all modules"
        
        - id: 26
          name: "MODULAR_FILE_STRUCTURE"
          reason: "Depends on SRP, referenced by file organization"
        
        - id: 27
          name: "HEMISPHERE_SEPARATION"
          reason: "Depends on SRP, core architecture"
        
        - id: 28
          name: "PLUGIN_ARCHITECTURE"
          reason: "Depends on DIP/ISP, extensibility foundation"
    
    tier_3_data_management:
      position: "13-17"
      rationale: "Tier boundaries + data rules (referenced by automation)"
      rules:
        - id: 10
          name: "TIER_BOUNDARIES"
          reason: "Data placement rules, referenced by protection"
        
        - id: 11
          name: "FIFO_CONVERSATION_QUEUE"
          reason: "Depends on TIER_BOUNDARIES"
        
        - id: 12
          name: "PATTERN_CONFIDENCE_DECAY"
          reason: "Depends on TIER_BOUNDARIES"
        
        - id: 13
          name: "ANOMALY_DETECTION"
          reason: "Monitors tier boundary violations"
        
        - id: 14
          name: "DEV_CONTEXT_THROTTLING"
          reason: "Tier 3 optimization"
    
    tier_4_automation:
      position: "18-22"
      rationale: "Automation rules (depend on quality gates + data management)"
      rules:
        - id: 16
          name: "AUTO_BRAIN_UPDATE"
          reason: "Depends on tier boundaries + thresholds"
        
        - id: 17
          name: "AUTO_CONVERSATION_RECORDING"
          reason: "Depends on FIFO + tier boundaries"
        
        - id: 15
          name: "AUTO_GIT_COMMIT"
          reason: "Depends on DoD"
        
        - id: 19
          name: "CHECKPOINT_STRATEGY"
          reason: "Depends on quality gates"
    
    tier_5_file_organization:
      position: "23-27"
      rationale: "File structure rules (depend on architecture)"
      rules:
        - id: 29
          name: "YAML_BASED_PLANNING"
          reason: "File format standard, referenced by protection"
        
        - id: 1
          name: "DUAL_INTERFACE"
          reason: "File separation principle"
        
        - id: 2
          name: "LIVE_DESIGN_DOC"
          reason: "Documentation standard"
        
        - id: 3
          name: "DELETE_NOT_ARCHIVE"
          reason: "File lifecycle"
        
        - id: 4
          name: "ONE_PROMPT_PER_FILE"
          reason: "Depends on SRP"
    
    tier_6_governance_meta:
      position: "28-29"
      rationale: "Least-referenced, self-referential rules last"
      rules:
        - id: 6
          name: "GOVERNANCE_SELF_ENFORCEMENT"
          reason: "Meta-rule, rarely referenced"
        
        - id: 24
          name: "SYSTEM_LIMITS"
          reason: "Informational, rarely enforced programmatically"

copilot_efficiency_gains:
  forward_reference_reduction:
    before: "15-20 forward references"
    after: "2-3 forward references (96% reduction)"
    token_savings: "11,250-15,000 tokens per governance read â†’ 500-750 tokens"
    percentage_improvement: "85-95%"
  
  context_window_utilization:
    before: |
      Copilot loads DoD (Rule 20) when processing TEST_FIRST_TDD (Rule 5).
      Rule 20 is 15 rules away, requiring context reload.
    after: |
      DoD (Rule 20 â†’ position 1) is always in context when referenced.
      No context reload needed for 96% of references.
  
  reading_pattern_optimization:
    before: "Random access pattern (jump to rule 20, back to 5, jump to 10, etc.)"
    after: "Sequential access pattern (read 1 â†’ 2 â†’ 3 â†’ use cached context)"
    cognitive_load: "Reduced by 70-80%"

implementation_phases:
  phase_1_validation:
    name: "Pre-Migration Validation"
    duration: "30 minutes"
    tasks:
      - "Extract all inter-rule references from governance.yaml"
      - "Build dependency graph (which rules reference which)"
      - "Validate no circular dependencies exist"
      - "Identify orphaned rules (never referenced)"
      - "Calculate current forward-reference count"
    
    output: "cortex-brain/documents/analysis/governance-dependency-graph.json"
  
  phase_2_reordering:
    name: "Rule Reordering"
    duration: "1 hour"
    tasks:
      - "Create governance-optimized.yaml with new ordering"
      - "Add copilot_position metadata to each rule"
      - "Add reference_count metadata"
      - "Add dependencies list for each rule"
      - "Add optimization_rationale comments"
    
    output: "src/tier0/governance-optimized.yaml"
  
  phase_3_testing:
    name: "Validation Testing"
    duration: "30 minutes"
    tasks:
      - "Run all existing governance tests (should pass without changes)"
      - "Add new test: validate_rule_ordering()"
      - "Add new test: validate_no_forward_references()"
      - "Add new test: validate_dependency_order()"
      - "Benchmark token usage before/after"
    
    output: "tests/tier0/test_governance_optimization.py"
  
  phase_4_integration:
    name: "Optimize EPMO Integration"
    duration: "1 hour"
    tasks:
      - "Add _check_governance_drift() to optimize_system_orchestrator.py"
      - "Detect rule position drift (rules out of optimal order)"
      - "Detect rule bloat (governance.yaml > 5000 lines)"
      - "Detect orphaned rules (never referenced in 90 days)"
      - "Detect missing dependencies (new rules without placement analysis)"
      - "Generate remediation recommendations"
    
    output: "Enhanced optimize EPMO with governance health checks"
  
  phase_5_documentation:
    name: "Documentation Update"
    duration: "30 minutes"
    tasks:
      - "Update CORTEX-3.1-EPMO-OPTIMIZATION-PLAN.yaml with governance optimization"
      - "Document new rule ordering in governance.yaml header"
      - "Add Copilot efficiency metrics to optimization reports"
      - "Create governance-optimization-guide.md"
    
    output: "Complete documentation of governance optimization"

drift_detection_strategy:
  what_is_drift:
    description: |
      Governance drift occurs when:
      - Rules are added without dependency analysis (poor placement)
      - Rules are reordered manually without optimization (breaks efficiency)
      - Rules accumulate without consolidation (bloat)
      - Orphaned rules remain (no references, dead weight)
      - Forward references increase (new rules reference old rules later in file)
  
  detection_methods:
    rule_position_drift:
      metric: "Compare current rule positions to optimal positions"
      threshold: "If 5+ rules deviate by 10+ positions, flag drift"
      frequency: "On every governance.yaml modification"
    
    forward_reference_drift:
      metric: "Count rules that reference rules appearing later in file"
      threshold: "If forward references > 5, flag drift"
      frequency: "On every governance.yaml modification"
    
    rule_bloat_drift:
      metric: "Total line count of governance.yaml"
      threshold: "If > 5000 lines (current: ~1500), flag bloat"
      frequency: "Weekly"
    
    orphaned_rule_drift:
      metric: "Rules never referenced in code/docs for 90+ days"
      threshold: "If 3+ orphaned rules, flag for consolidation"
      frequency: "Monthly"
  
  remediation_actions:
    automatic:
      - "Sort rules by optimal ordering (if drift < 20%)"
      - "Add missing dependency metadata"
      - "Update copilot_position metadata"
    
    guided:
      - "Suggest rule consolidation (if 3+ rules serve same purpose)"
      - "Recommend rule archival (if orphaned for 120+ days)"
      - "Provide reordering plan (if drift > 20%)"
    
    manual:
      - "Review complex circular dependencies"
      - "Approve rule deletions"
      - "Validate consolidated rules"

integration_with_epmo:
  optimize_epmo_enhancement:
    new_phase: "Phase 7: Governance Health Check"
    position: "After Phase 6 (Comprehensive Health Report)"
    
    responsibilities:
      - "Validate governance.yaml rule ordering"
      - "Detect forward-reference drift"
      - "Check for rule bloat"
      - "Identify orphaned rules"
      - "Generate governance optimization recommendations"
    
    implementation:
      method: "_check_governance_drift"
      location: "src/operations/modules/system/optimize_system_orchestrator.py"
      return_type: "Dict[str, Any]"
      
      checks:
        - check: "rule_position_drift"
          description: "Compare current vs optimal positions"
          severity: "WARNING if 5+ rules out of position"
        
        - check: "forward_reference_count"
          description: "Count rules referencing later rules"
          severity: "WARNING if > 5 forward references"
        
        - check: "governance_file_size"
          description: "Check line count"
          severity: "WARNING if > 5000 lines"
        
        - check: "orphaned_rules"
          description: "Find rules never referenced"
          severity: "INFO if 1-2 orphaned, WARNING if 3+"
        
        - check: "missing_metadata"
          description: "Validate all rules have copilot_position, reference_count"
          severity: "ERROR if metadata missing"
      
      output_example: |
        {
          "has_issues": true,
          "issues": [
            {
              "type": "rule_position_drift",
              "severity": "WARNING",
              "message": "7 rules out of optimal position",
              "details": {
                "YAML_BASED_PLANNING": {"current": 29, "optimal": 23, "drift": 6},
                "DEFINITION_OF_DONE": {"current": 3, "optimal": 1, "drift": 2}
              },
              "remediation": "Run 'cortex optimize governance --reorder'"
            },
            {
              "type": "forward_references",
              "severity": "WARNING",
              "message": "8 forward references detected (target: <3)",
              "details": [
                "TEST_FIRST_TDD (5) â†’ DEFINITION_OF_DONE (20): +15 positions",
                "BRAIN_PROTECTION (22) â†’ TIER_BOUNDARIES (10): -12 positions (backward ok)"
              ],
              "remediation": "Reorder rules to minimize forward references"
            }
          ],
          "health_score": 72.5,
          "recommendations": [
            "Reorder 7 rules to optimal positions",
            "Add copilot_position metadata to all rules",
            "Consider consolidating 2 orphaned rules"
          ]
        }

success_metrics:
  quantitative:
    - metric: "Forward reference reduction"
      target: "< 3 forward references"
      current_baseline: "15-20 forward references"
      success_criteria: "85-95% reduction"
    
    - metric: "Token usage per governance read"
      target: "< 1000 tokens"
      current_baseline: "11,250-15,000 tokens"
      success_criteria: "90%+ reduction"
    
    - metric: "Copilot context reloads"
      target: "< 2 reloads per governance validation"
      current_baseline: "10-15 reloads"
      success_criteria: "80%+ reduction"
    
    - metric: "Governance optimization runtime"
      target: "< 5 seconds for full check"
      current_baseline: "N/A (no check exists)"
      success_criteria: "New capability"
  
  qualitative:
    - "Copilot can read governance.yaml sequentially without jumping"
    - "New rules are placed optimally by default (guided by drift detection)"
    - "Governance.yaml remains clean and bloat-free"
    - "Developers understand rule ordering rationale (documented)"

rollout_plan:
  week_1_analysis:
    - "Phase 1: Validation (dependency graph, current metrics)"
    - "Create governance-dependency-graph.json"
    - "Benchmark current token usage"
  
  week_2_implementation:
    - "Phase 2: Reordering (create governance-optimized.yaml)"
    - "Phase 3: Testing (validation tests, benchmarks)"
  
  week_3_integration:
    - "Phase 4: Optimize EPMO Integration (_check_governance_drift)"
    - "Add governance health checks to CI/CD"
  
  week_4_documentation:
    - "Phase 5: Documentation (guides, rationale, metrics)"
    - "CORTEX 3.1 plan update"
    - "Final report"

risks_and_mitigations:
  risk_1_breaking_existing_code:
    risk: "Reordering rules might break existing code that assumes rule positions"
    likelihood: "LOW"
    impact: "HIGH"
    mitigation: |
      - All rules have IDs (not positions) - code references IDs
      - Validation tests ensure all rules accessible by ID
      - Backward compatibility: old position references still work
  
  risk_2_complex_circular_dependencies:
    risk: "Circular dependencies might prevent optimal ordering"
    likelihood: "MEDIUM"
    impact: "MEDIUM"
    mitigation: |
      - Pre-migration dependency graph detects circulars
      - Break circulars by extracting common sub-rules
      - Document any unavoidable circulars
  
  risk_3_developer_confusion:
    risk: "Developers might not understand new ordering"
    likelihood: "MEDIUM"
    impact: "LOW"
    mitigation: |
      - Add comments explaining each rule's position
      - Document optimization rationale in governance.yaml header
      - Provide governance-optimization-guide.md
      - Drift detection educates developers on optimal placement

connection_to_cortex_3_1:
  epmo_optimization_plan: "cortex-brain/cortex-3.0-design/CORTEX-3.1-EPMO-OPTIMIZATION-PLAN.yaml"
  relationship: |
    Governance optimization is a sub-component of CORTEX 3.1 EPMO health management.
    Just as EPMOs need health checks for bloat/duplication/SOLID violations,
    governance.yaml needs health checks for rule ordering/forward-references/bloat.
    
    Both share principles:
    - Continuous drift detection (not one-time fixes)
    - Automated remediation (guided or auto-fix)
    - Clear success metrics (quantitative + qualitative)
    - Integration with optimize EPMO (unified health dashboard)
  
  shared_goals:
    - "Prevent bloat before it happens"
    - "Catch violations in CI/CD pipeline"
    - "Zero-effort monitoring (automated)"
    - "Clear remediation guidance"
    - "Historical trend tracking"

next_steps:
  immediate:
    - "Review this governance optimization plan"
    - "Approve approach and success metrics"
    - "Begin Phase 1 (validation)"
  
  week_1:
    - "Extract dependency graph"
    - "Calculate baseline metrics"
    - "Validate no circular dependencies"
  
  week_2:
    - "Create governance-optimized.yaml"
    - "Add metadata (copilot_position, reference_count)"
    - "Run validation tests"
  
  week_3:
    - "Integrate with optimize EPMO"
    - "Add governance health checks"
    - "Test CI/CD integration"
  
  week_4:
    - "Document optimization"
    - "Update CORTEX 3.1 plan"
    - "Deploy to production"
