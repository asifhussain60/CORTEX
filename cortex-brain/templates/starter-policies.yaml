# Starter Policy Template for CORTEX Setup
# Generated by CORTEX Policy Scanner
#
# This template provides sensible defaults for:
# - Naming conventions
# - Security rules
# - Code standards  
# - Architecture patterns
#
# Customize these policies to match your organization's requirements.

naming_conventions:
  # Variable naming
  - Use descriptive variable names with minimum 3 characters
  - Avoid single-letter variables except for loop counters (i, j, k)
  
  # Class naming
  - Class names use PascalCase (e.g., UserAuthentication, PaymentProcessor)
  - No underscores in class names
  
  # Function naming
  - Function names use snake_case (e.g., process_payment, validate_user)
  - Functions should be verb phrases (get_user, not user)
  
  # Constants
  - Constants use UPPER_CASE with underscores (e.g., MAX_RETRIES, API_KEY)
  
  # File naming
  - Python files use snake_case (e.g., user_service.py, payment_gateway.py)
  - Test files prefix with test_ (e.g., test_user_service.py)

security_rules:
  # Credentials and secrets
  - No hardcoded passwords, API keys, or tokens in source code
  - Use environment variables for all sensitive configuration
  - Store secrets in secure vault (e.g., Azure Key Vault, AWS Secrets Manager)
  
  # Authentication
  - Implement multi-factor authentication for admin access
  - Use strong password policies (min 12 chars, complexity requirements)
  - Session tokens must expire after 30 minutes of inactivity
  
  # Input validation
  - Validate and sanitize all user inputs
  - Use parameterized queries to prevent SQL injection
  - Escape output to prevent XSS attacks
  
  # Data handling
  - Encrypt sensitive data at rest and in transit
  - Use TLS 1.2+ for all network communications
  - Log security events (failed logins, permission changes)

code_standards:
  # Documentation
  - Include docstrings for all public functions and classes
  - Document parameters, return values, and exceptions
  - Maintain up-to-date README with setup instructions
  
  # Testing
  - Maintain minimum 70% code coverage
  - Write unit tests for all business logic
  - Include integration tests for critical paths
  - Run tests before every commit
  
  # Code quality
  - Run linter (pylint, flake8) before committing
  - Fix all critical and high-severity issues
  - Keep cyclomatic complexity below 10 per function
  - Maximum function length: 50 lines
  
  # Version control
  - Write clear, descriptive commit messages
  - Use feature branches for development
  - Require code review before merging to main
  - Tag releases with semantic versioning

architecture_patterns:
  # Design principles
  - Follow SOLID principles
  - Maintain separation of concerns
  - Use dependency injection for loose coupling
  
  # Layering
  - Separate presentation, business logic, and data access layers
  - No business logic in UI components
  - No direct database access from presentation layer
  
  # Error handling
  - Use structured exception handling
  - Log errors with context (timestamp, user, action)
  - Provide user-friendly error messages
  - Implement retry logic for transient failures
  
  # Performance
  - Avoid N+1 query problems
  - Use caching for frequently accessed data
  - Implement pagination for large result sets
  - Monitor and log performance metrics
  
  # Scalability
  - Design for horizontal scaling
  - Use message queues for async processing
  - Avoid stateful services where possible
  - Implement graceful degradation

# Custom rules (add your organization-specific policies here)
custom_rules:
  # Example: Technology stack restrictions
  # - Python 3.8+ required
  # - No GPL-licensed dependencies
  # - Use PostgreSQL for relational data
  
  # Example: Deployment requirements
  # - All services must have health check endpoints
  # - Docker containers must run as non-root user
  # - Kubernetes deployments require resource limits

# Exceptions (rules that don't apply to this project)
exceptions:
  # Example: Legacy code exceptions
  # - payment_legacy.py exempt from test coverage requirement
  # - admin_tool.py exempt from docstring requirement (deprecated)

# --------------------------------------------------
# How to Use This Template
# --------------------------------------------------
#
# 1. Review and Customize
#    - Adjust rules to match your organization's standards
#    - Add custom rules specific to your tech stack
#    - Document any exceptions
#
# 2. Validate CORTEX Compliance
#    Run: python src/validation/policy_validator.py <repo_root>
#    This checks if CORTEX configuration follows your policies
#
# 3. Generate Compliance Report
#    Report saved to: cortex-brain/documents/reports/policy-compliance.md
#    Review violations and apply recommendations
#
# 4. Continuous Compliance
#    - Re-run validation after CORTEX configuration changes
#    - Update policies as organizational standards evolve
#    - Use realignment orchestrator to auto-fix violations
#
# 5. Share with Team
#    Commit this file to version control so team members
#    can validate their CORTEX setups against the same policies
