tier1_working_memory_api:
  name: "Tier 1 Working Memory API"
  version: "2.0"
  purpose: "Short-term conversation memory (last 20 conversations)"
  
  overview:
    storage: "cortex-brain/tier1/conversations.db (SQLite)"
    performance_target: "<50ms per query"
    actual_performance: "18ms average"
    
  core_classes:
    WorkingMemory:
      location: "src/tier1/working_memory.py"
      purpose: "Main interface for conversation storage and retrieval"
      
      methods:
        store_conversation:
          parameters:
            user_message: "string"
            assistant_response: "string" 
            intent: "string"
            context: "dict (optional)"
          returns: "conversation_id"
          example: |
            memory = WorkingMemory()
            conv_id = memory.store_conversation(
                user_message="Add a purple button to the control panel",
                assistant_response="I'll create that button with purple styling",
                intent="EXECUTE",
                context={
                    "files_modified": ["HostControlPanel.razor"],
                    "entities": ["button", "control panel", "purple"],
                    "agent": "code-executor"
                }
            )
            
        get_recent_conversations:
          parameters:
            limit: "integer (default: 5)"
          returns: "list of conversations"
          example: |
            recent = memory.get_recent_conversations(limit=5)
            
        search_conversations:
          parameters:
            query: "string"
            filters: "dict (optional)"
            limit: "integer (default: 10)"
          returns: "list of matching conversations"
          example: |
            results = memory.search_conversations(
                query="purple button",
                filters={
                    "intent": "EXECUTE", 
                    "date_range": ("2025-11-01", "2025-11-08")
                }
            )
            
        get_conversation_context:
          parameters:
            conversation_id: "string"
          returns: "dict with full context"
          example: |
            context = memory.get_conversation_context(conv_id)
            # Returns: current_conversation, previous_messages, 
            #          related_entities, file_references, etc.

  fifo_queue_management:
    configuration:
      max_conversations: 20
      enabled: true
      auto_cleanup: true
      
    methods:
      configure_fifo:
        parameters:
          max_conversations: "integer"
          enabled: "boolean"
          auto_cleanup: "boolean"
        example: |
          memory.configure_fifo(max_conversations=20, enabled=True)
          
      get_queue_status:
        returns:
          current_count: "integer"
          max_capacity: "integer"
          next_to_delete: "conversation_id (if at limit)"
          fifo_enabled: "boolean"
        example: |
          status = memory.get_queue_status()
          
      cleanup_old_conversations:
        returns: "integer (number deleted)"
        example: |
          deleted_count = memory.cleanup_old_conversations()

  entity_tracking:
    supported_types: ["file", "class", "method", "component", "variable"]
    
    methods:
      track_entity:
        parameters:
          conversation_id: "string"
          entity_type: "string" 
          entity_value: "string"
          context: "string (optional)"
        example: |
          memory.track_entity(
              conversation_id=conv_id,
              entity_type="file",
              entity_value="HostControlPanel.razor", 
              context="Modified to add button"
          )
          
      get_entities:
        parameters:
          conversation_id: "string (optional)"
          entity_type: "string (optional)"
        returns: "list of entities"
        example: |
          entities = memory.get_entities(conversation_id=conv_id)

  database_schema:
    conversations_table:
      fields:
        conversation_id: "TEXT PRIMARY KEY"
        user_message: "TEXT NOT NULL"
        assistant_response: "TEXT"
        intent: "TEXT"
        timestamp: "DATETIME DEFAULT CURRENT_TIMESTAMP"
        context_json: "TEXT"
        is_active: "BOOLEAN DEFAULT 1"
        
    messages_table:
      fields:
        message_id: "TEXT PRIMARY KEY"
        conversation_id: "TEXT" 
        role: "TEXT (user|assistant)"
        content: "TEXT"
        sequence_num: "INTEGER"
        timestamp: "DATETIME DEFAULT CURRENT_TIMESTAMP"
        
    entities_table:
      fields:
        entity_id: "TEXT PRIMARY KEY"
        conversation_id: "TEXT"
        entity_type: "TEXT"
        entity_value: "TEXT" 
        context: "TEXT"

    indexes:
      - "idx_conversations_timestamp ON conversations(timestamp DESC)"
      - "idx_messages_conversation ON messages(conversation_id, sequence_num)"
      - "idx_entities_conversation ON entities(conversation_id)"
      - "idx_entities_type_value ON entities(entity_type, entity_value)"

  performance:
    targets:
      store_conversation: "<30ms"
      query_recent: "<50ms" 
      search: "<100ms"
    
    optimizations:
      sqlite_pragmas:
        - "PRAGMA journal_mode=WAL"
        - "PRAGMA synchronous=NORMAL"
        - "PRAGMA cache_size=10000"
      indexing_strategy: "Covering indexes for common queries"
      connection_pooling: true

  error_handling:
    database_locked: "Retry with exponential backoff"
    disk_full: "Trigger cleanup_old_conversations()"
    invalid_conversation_id: "Return None gracefully"
    malformed_context: "Store as string, log warning"

  example_usage:
    initialization: |
      from src.tier1.working_memory import WorkingMemory
      memory = WorkingMemory()
      
    typical_workflow: |
      # Store new conversation
      conv_id = memory.store_conversation(
          user_message="Add logout functionality",
          assistant_response="I'll implement logout with session cleanup",
          intent="PLAN"
      )
      
      # Track entities
      memory.track_entity(conv_id, "component", "logout", "Authentication")
      
      # Search for related conversations  
      related = memory.search_conversations("authentication logout")
      
      # Get context for continuity
      context = memory.get_conversation_context(conv_id)