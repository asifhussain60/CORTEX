<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORTEX Interactive Dashboard</title>
    
    <!-- D3.js v7 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <!-- html2canvas for PNG export (Phase 2.4) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <!-- Dashboard CSS -->
    <link rel="stylesheet" href="dashboard.css">
    
    <style>
        /* Inline critical CSS for faster initial render */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #f9fafb;
            color: #111827;
            padding: 2rem;
        }
        
        .dashboard-container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .dashboard-header {
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .dashboard-title {
            font-size: 2rem;
            font-weight: 700;
            color: #111827;
            margin-bottom: 0.5rem;
        }
        
        .dashboard-subtitle {
            font-size: 0.875rem;
            color: #6b7280;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .chart-card {
            background: #ffffff;
            border-radius: 8px;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .chart-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: #111827;
        }
        
        .chart-container {
            position: relative;
            width: 100%;
            min-height: 300px;
        }
        
        .placeholder-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            color: #6b7280;
        }
        
        .placeholder-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.3;
        }
        
        .placeholder-message {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        
        .placeholder-description {
            font-size: 0.875rem;
            text-align: center;
            max-width: 300px;
        }
        
        /* Responsive */
        @media (max-width: 1024px) {
            .chart-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* D3.js Chart Styles */
        .axis-label {
            font-size: 0.875rem;
            fill: #6b7280;
        }
        
        .chart-line {
            fill: none;
            stroke: #3b82f6;
            stroke-width: 2px;
        }
        
        .chart-area {
            fill: rgba(59, 130, 246, 0.2);
        }
        
        .tooltip {
            position: absolute;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- Dashboard Header -->
        <header class="dashboard-header">
            <h1 class="dashboard-title">üß† CORTEX Interactive Dashboard</h1>
            <p class="dashboard-subtitle">
                Generated: {{ timestamp }} | 
                Author: Asif Hussain | 
                Repository: CORTEX
            </p>
        </header>
        
        <!-- Chart Grid -->
        <div class="chart-grid">
            <!-- Health Trend Chart -->
            <div class="chart-card">
                <h2 class="chart-title">üìà Architecture Health Trend</h2>
                <div id="health-trend-chart" class="chart-container"></div>
            </div>
            
            <!-- Integration Heatmap -->
            <div class="chart-card">
                <h2 class="chart-title">üî• Integration Heatmap</h2>
                <div id="integration-heatmap" class="chart-container"></div>
            </div>
            
            <!-- Test Coverage Gauge -->
            <div class="chart-card">
                <h2 class="chart-title">üéØ Test Coverage</h2>
                <div id="test-coverage-gauge" class="chart-container"></div>
            </div>
            
            <!-- Code Quality Radar -->
            <div class="chart-card">
                <h2 class="chart-title">üåü Code Quality Radar</h2>
                <div id="code-quality-radar" class="chart-container"></div>
            </div>
        </div>
    </div>
    
    <!-- Tooltip Container -->
    <div id="tooltip" class="tooltip"></div>
    
    <!-- Export & Filter Controls (Phase 2) -->
    <div style="position: fixed; bottom: 20px; right: 20px; display: flex; gap: 10px; z-index: 1001;">
        <button id="export-png-btn" class="export-btn" title="Export as PNG">üì∑ PNG</button>
        <button id="export-svg-btn" class="export-btn" title="Export as SVG">üñºÔ∏è SVG</button>
        <button id="export-json-btn" class="export-btn" title="Export Data as JSON">üìä JSON</button>
        <button id="filter-btn" class="export-btn" title="Filter Data">üîç Filter</button>
    </div>
    
    <!-- Filter Modal (hidden by default) -->
    <div id="filter-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 1002; min-width: 300px;">
        <h3 style="margin-top: 0;">Filter Dashboard Data</h3>
        <div style="margin-bottom: 15px;">
            <label for="date-range">Date Range:</label>
            <select id="date-range" style="width: 100%; padding: 5px;">
                <option value="7">Last 7 days</option>
                <option value="30" selected>Last 30 days</option>
                <option value="90">Last 90 days</option>
                <option value="all">All time</option>
            </select>
        </div>
        <div style="margin-bottom: 15px;">
            <label for="feature-type">Feature Type:</label>
            <select id="feature-type" style="width: 100%; padding: 5px;">
                <option value="all" selected>All Features</option>
                <option value="operation">Operations</option>
                <option value="agent">Agents</option>
                <option value="orchestrator">Orchestrators</option>
            </select>
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end;">
            <button id="filter-apply-btn" style="padding: 8px 16px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;">Apply</button>
            <button id="filter-cancel-btn" style="padding: 8px 16px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
        </div>
    </div>
    
    <!-- Chart Data (injected by Python) -->
    <script>
        // Chart configurations from ChartConfigBuilder
        const chartConfigs = {{ chart_configs | tojson }};
        
        // Enhanced Tooltip System (Phase 2.1)
        const TooltipManager = {
            tooltip: d3.select('#tooltip'),
            
            show(content, event) {
                const pos = this.calculatePosition(event);
                this.tooltip
                    .html(content)
                    .style('left', pos.left + 'px')
                    .style('top', pos.top + 'px')
                    .style('visibility', 'visible')
                    .style('opacity', '1');
            },
            
            hide() {
                this.tooltip
                    .style('opacity', '0')
                    .style('visibility', 'hidden');
            },
            
            calculatePosition(event) {
                const tooltipNode = this.tooltip.node();
                const tooltipWidth = tooltipNode.offsetWidth;
                const tooltipHeight = tooltipNode.offsetHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                
                let left = event.pageX + 10;
                let top = event.pageY - 10;
                
                // Prevent right edge overflow
                if (left + tooltipWidth > windowWidth) {
                    left = event.pageX - tooltipWidth - 10;
                }
                
                // Prevent bottom edge overflow
                if (top + tooltipHeight > windowHeight) {
                    top = event.pageY - tooltipHeight - 10;
                }
                
                // Prevent top edge overflow
                if (top < 0) {
                    top = event.pageY + 10;
                }
                
                return { left, top };
            }
        };
        
        // Zoom & Pan Manager (Phase 2.2)
        const ZoomManager = {
            zoom: null,
            
            enableZoom(svg, xScale, yScale, line, area, data, margin) {
                this.zoom = d3.zoom()
                    .scaleExtent([1, 10])
                    .translateExtent([[0, 0], [svg.attr('width'), svg.attr('height')]])
                    .on('zoom', (event) => {
                        const newXScale = event.transform.rescaleX(xScale);
                        const newYScale = event.transform.rescaleY(yScale);
                        
                        // Update axes
                        svg.select('.x-axis').call(d3.axisBottom(newXScale));
                        svg.select('.y-axis').call(d3.axisLeft(newYScale));
                        
                        // Update line
                        svg.select('.chart-line')
                            .attr('d', d3.line()
                                .x(d => newXScale(d.x))
                                .y(d => newYScale(d.y))(data));
                        
                        // Update area
                        svg.select('.chart-area')
                            .attr('d', d3.area()
                                .x(d => newXScale(d.x))
                                .y0(svg.attr('height') - margin.bottom)
                                .y1(d => newYScale(d.y))(data));
                    });
                
                svg.call(this.zoom);
            },
            
            reset(svg) {
                if (this.zoom) {
                    svg.transition().duration(750).call(this.zoom.transform, d3.zoomIdentity);
                }
            }
        };
        
        // Export Manager (Phase 2.4)
        const ExportManager = {
            exportAsPNG(elementId, filename) {
                const element = document.getElementById(elementId);
                html2canvas(element).then(canvas => {
                    const link = document.createElement('a');
                    link.download = filename || 'dashboard.png';
                    link.href = canvas.toDataURL();
                    link.click();
                });
            },
            
            exportAsSVG(elementId, filename) {
                const element = document.getElementById(elementId);
                const svgElement = element.querySelector('svg');
                if (!svgElement) {
                    alert('No SVG element found');
                    return;
                }
                
                const serializer = new XMLSerializer();
                const svgString = serializer.serializeToString(svgElement);
                const blob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.download = filename || 'chart.svg';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            },
            
            exportAsJSON(data, filename) {
                const jsonString = JSON.stringify(data, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.download = filename || 'data.json';
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            }
        };
        
        // Filter Manager (Phase 2.3)
        const FilterManager = {
            currentFilters: {
                dateRange: 30,
                featureType: 'all'
            },
            
            showModal() {
                document.getElementById('filter-modal').style.display = 'block';
            },
            
            hideModal() {
                document.getElementById('filter-modal').style.display = 'none';
            },
            
            applyFilters() {
                this.currentFilters.dateRange = parseInt(document.getElementById('date-range').value);
                this.currentFilters.featureType = document.getElementById('feature-type').value;
                this.hideModal();
                // Trigger chart re-render with new filters
                this.refreshCharts();
            },
            
            refreshCharts() {
                // Re-render all charts with filtered data
                Object.entries(chartConfigs).forEach(([key, config]) => {
                    if (config.type === 'placeholder') return;
                    
                    // Apply filters to data
                    const filteredConfig = this.filterChartData(config, this.currentFilters);
                    
                    // Re-render chart
                    const renderMethod = `render${key.replace(/-/g, '')}`;
                    if (ChartRenderer[renderMethod]) {
                        ChartRenderer[renderMethod](key + '-chart', filteredConfig);
                    }
                });
            },
            
            filterChartData(config, filters) {
                // Clone config to avoid modifying original
                const filteredConfig = JSON.parse(JSON.stringify(config));
                
                if (!filteredConfig.data) return filteredConfig;
                
                // Apply date range filter
                if (filters.dateRange !== 'all' && filteredConfig.data.length > 0) {
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - filters.dateRange);
                    filteredConfig.data = filteredConfig.data.filter(d => 
                        new Date(d.x || d.date || 0) >= cutoffDate
                    );
                }
                
                // Apply feature type filter (if applicable)
                if (filters.featureType !== 'all' && filteredConfig.features) {
                    filteredConfig.features = filteredConfig.features.filter(f => 
                        f.type === filters.featureType
                    );
                }
                
                return filteredConfig;
            }
        };
        
        // Initialize event listeners (Phase 2)
        document.addEventListener('DOMContentLoaded', () => {
            // Export button handlers
            document.getElementById('export-png-btn').addEventListener('click', () => {
                ExportManager.exportAsPNG('health-trend-chart', 'health-trend.png');
            });
            
            document.getElementById('export-svg-btn').addEventListener('click', () => {
                ExportManager.exportAsSVG('health-trend-chart', 'health-trend.svg');
            });
            
            document.getElementById('export-json-btn').addEventListener('click', () => {
                ExportManager.exportAsJSON(chartConfigs, 'dashboard-data.json');
            });
            
            document.getElementById('filter-btn').addEventListener('click', () => {
                FilterManager.showModal();
            });
            
            // Filter modal handlers
            document.getElementById('filter-apply-btn').addEventListener('click', () => {
                FilterManager.applyFilters();
            });
            
            document.getElementById('filter-cancel-btn').addEventListener('click', () => {
                FilterManager.hideModal();
            });
        });
        
        // Chart rendering functions
        const ChartRenderer = {
            // Health Trend Line Chart
            renderHealthTrend(containerId, config) {
                const container = d3.select(`#${containerId}`);
                container.selectAll('*').remove();
                
                if (config.type === 'placeholder') {
                    this.renderPlaceholder(container, config);
                    return;
                }
                
                const margin = { top: 20, right: 30, bottom: 40, left: 50 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const height = 300 - margin.top - margin.bottom;
                
                const svg = container.append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom)
                    .append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Parse dates and create scales
                const parseDate = d3.timeParse('%Y-%m-%d');
                const data = config.data.map(d => ({
                    date: parseDate(d.date),
                    score: d.score
                }));
                
                const x = d3.scaleTime()
                    .domain(d3.extent(data, d => d.date))
                    .range([0, width]);
                
                const y = d3.scaleLinear()
                    .domain([0, 100])
                    .range([height, 0]);
                
                // Add axes
                svg.append('g')
                    .attr('transform', `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(5))
                    .selectAll('text')
                    .attr('class', 'axis-label');
                
                svg.append('g')
                    .call(d3.axisLeft(y).ticks(5))
                    .selectAll('text')
                    .attr('class', 'axis-label');
                
                // Add line
                const line = d3.line()
                    .x(d => x(d.date))
                    .y(d => y(d.score))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(data)
                    .attr('class', 'chart-line')
                    .attr('d', line);
                
                // Add area
                const area = d3.area()
                    .x(d => x(d.date))
                    .y0(height)
                    .y1(d => y(d.score))
                    .curve(d3.curveMonotoneX);
                
                svg.append('path')
                    .datum(data)
                    .attr('class', 'chart-area')
                    .attr('d', area);
                
                // Add velocity indicator
                if (config.velocity) {
                    const velocityColor = config.velocity > 0 ? '#10b981' : 
                                        config.velocity < 0 ? '#ef4444' : '#6b7280';
                    const velocityText = config.velocity > 0 ? '‚ÜóÔ∏è Improving' :
                                       config.velocity < 0 ? '‚ÜòÔ∏è Degrading' : '‚Üí Stable';
                    
                    svg.append('text')
                        .attr('x', width - 10)
                        .attr('y', 15)
                        .attr('text-anchor', 'end')
                        .style('fill', velocityColor)
                        .style('font-size', '0.875rem')
                        .style('font-weight', 600)
                        .text(velocityText);
                }
                
                // Add tooltips
                const tooltip = d3.select('#tooltip');
                svg.selectAll('.dot')
                    .data(data)
                    .enter().append('circle')
                    .attr('class', 'dot')
                    .attr('cx', d => x(d.date))
                    .attr('cy', d => y(d.score))
                    .attr('r', 4)
                    .attr('fill', '#3b82f6')
                    .style('opacity', 0)
                    .on('mouseover', (event, d) => {
                        d3.select(event.target).style('opacity', 1);
                        tooltip.style('opacity', 1)
                            .html(`Date: ${d.date.toLocaleDateString()}<br/>Score: ${d.score}%`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', (event) => {
                        d3.select(event.target).style('opacity', 0);
                        tooltip.style('opacity', 0);
                    });
            },
            
            // Integration Heatmap
            renderIntegrationHeatmap(containerId, config) {
                const container = d3.select(`#${containerId}`);
                container.selectAll('*').remove();
                
                if (config.type === 'placeholder') {
                    this.renderPlaceholder(container, config);
                    return;
                }
                
                const margin = { top: 40, right: 20, bottom: 100, left: 120 };
                const width = container.node().getBoundingClientRect().width - margin.left - margin.right;
                const cellSize = 40;
                const height = config.layers.length * cellSize;
                
                const svg = container.append('svg')
                    .attr('width', width + margin.left + margin.right)
                    .attr('height', height + margin.top + margin.bottom)
                    .append('g')
                    .attr('transform', `translate(${margin.left},${margin.top})`);
                
                // Color scale
                const colorScale = d3.scaleSequential(d3.interpolateRdYlGn)
                    .domain([0, 100]);
                
                // Scales
                const maxFeatures = d3.max(config.layers, layer => layer.features.length);
                const x = d3.scaleBand()
                    .domain(d3.range(maxFeatures))
                    .range([0, width])
                    .padding(0.1);
                
                const y = d3.scaleBand()
                    .domain(config.layers.map(l => l.name))
                    .range([0, height])
                    .padding(0.1);
                
                // Render cells
                const tooltip = d3.select('#tooltip');
                config.layers.forEach(layer => {
                    svg.selectAll(`.cell-${layer.name}`)
                        .data(layer.features)
                        .enter().append('rect')
                        .attr('class', `cell-${layer.name}`)
                        .attr('x', (d, i) => x(i))
                        .attr('y', y(layer.name))
                        .attr('width', x.bandwidth())
                        .attr('height', y.bandwidth())
                        .attr('fill', d => colorScale(d.score))
                        .attr('stroke', '#ffffff')
                        .attr('stroke-width', 2)
                        .on('mouseover', (event, d) => {
                            tooltip.style('opacity', 1)
                                .html(`Feature: ${d.name}<br/>Layer: ${layer.name}<br/>Score: ${d.score}%`)
                                .style('left', (event.pageX + 10) + 'px')
                                .style('top', (event.pageY - 10) + 'px');
                        })
                        .on('mouseout', () => {
                            tooltip.style('opacity', 0);
                        });
                });
                
                // Add y-axis labels
                svg.append('g')
                    .selectAll('text')
                    .data(config.layers)
                    .enter().append('text')
                    .attr('x', -10)
                    .attr('y', d => y(d.name) + y.bandwidth() / 2)
                    .attr('text-anchor', 'end')
                    .attr('dominant-baseline', 'middle')
                    .attr('class', 'axis-label')
                    .text(d => d.name);
                
                // Add legend
                const legendWidth = 200;
                const legendHeight = 10;
                const legendScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, legendWidth]);
                
                const legendAxis = d3.axisBottom(legendScale)
                    .ticks(5)
                    .tickFormat(d => `${d}%`);
                
                const legend = svg.append('g')
                    .attr('transform', `translate(${width - legendWidth}, ${height + 20})`);
                
                legend.selectAll('rect')
                    .data(d3.range(0, 101, 1))
                    .enter().append('rect')
                    .attr('x', d => legendScale(d))
                    .attr('y', 0)
                    .attr('width', legendWidth / 100)
                    .attr('height', legendHeight)
                    .attr('fill', d => colorScale(d));
                
                legend.append('g')
                    .attr('transform', `translate(0, ${legendHeight})`)
                    .call(legendAxis)
                    .selectAll('text')
                    .attr('class', 'axis-label');
            },
            
            // Test Coverage Gauge
            renderTestCoverageGauge(containerId, config) {
                const container = d3.select(`#${containerId}`);
                container.selectAll('*').remove();
                
                if (config.type === 'placeholder') {
                    this.renderPlaceholder(container, config);
                    return;
                }
                
                const width = container.node().getBoundingClientRect().width;
                const height = 300;
                const radius = Math.min(width, height) / 2 - 20;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width/2},${height/2})`);
                
                // Arc generator
                const arc = d3.arc()
                    .innerRadius(radius * 0.6)
                    .outerRadius(radius)
                    .startAngle(-Math.PI / 2);
                
                // Background arc
                svg.append('path')
                    .datum({endAngle: Math.PI / 2})
                    .attr('class', 'background-arc')
                    .attr('d', arc)
                    .attr('fill', '#e5e7eb');
                
                // Foreground arc (animated)
                const coveragePercent = config.coverage / 100;
                const coverageAngle = -Math.PI / 2 + (Math.PI * coveragePercent);
                
                const coverageColor = config.coverage < 70 ? '#ef4444' :
                                    config.coverage < 85 ? '#f59e0b' : '#10b981';
                
                const foregroundArc = svg.append('path')
                    .datum({endAngle: -Math.PI / 2})
                    .attr('class', 'foreground-arc')
                    .attr('d', arc)
                    .attr('fill', coverageColor);
                
                // Animate
                foregroundArc.transition()
                    .duration(1000)
                    .attrTween('d', function(d) {
                        const interpolate = d3.interpolate(d.endAngle, coverageAngle);
                        return function(t) {
                            d.endAngle = interpolate(t);
                            return arc(d);
                        };
                    });
                
                // Center text
                svg.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .style('font-size', '2.5rem')
                    .style('font-weight', 700)
                    .style('fill', coverageColor)
                    .text(`${config.coverage}%`);
                
                svg.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .attr('y', 30)
                    .style('font-size', '0.875rem')
                    .style('fill', '#6b7280')
                    .text('Coverage');
            },
            
            // Code Quality Radar
            renderCodeQualityRadar(containerId, config) {
                const container = d3.select(`#${containerId}`);
                container.selectAll('*').remove();
                
                if (config.type === 'placeholder') {
                    this.renderPlaceholder(container, config);
                    return;
                }
                
                const width = container.node().getBoundingClientRect().width;
                const height = 300;
                const radius = Math.min(width, height) / 2 - 50;
                
                const svg = container.append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .append('g')
                    .attr('transform', `translate(${width/2},${height/2})`);
                
                // Radar scales
                const angleSlice = (Math.PI * 2) / config.dimensions.length;
                const rScale = d3.scaleLinear()
                    .domain([0, 100])
                    .range([0, radius]);
                
                // Draw grid circles
                const gridLevels = 5;
                for (let i = 1; i <= gridLevels; i++) {
                    svg.append('circle')
                        .attr('r', radius * (i / gridLevels))
                        .attr('fill', 'none')
                        .attr('stroke', '#e5e7eb')
                        .attr('stroke-width', 1);
                }
                
                // Draw axes
                config.dimensions.forEach((dim, i) => {
                    const angle = angleSlice * i - Math.PI / 2;
                    const x = rScale(100) * Math.cos(angle);
                    const y = rScale(100) * Math.sin(angle);
                    
                    svg.append('line')
                        .attr('x1', 0)
                        .attr('y1', 0)
                        .attr('x2', x)
                        .attr('y2', y)
                        .attr('stroke', '#e5e7eb')
                        .attr('stroke-width', 1);
                    
                    // Axis labels
                    const labelRadius = rScale(100) + 30;
                    const labelX = labelRadius * Math.cos(angle);
                    const labelY = labelRadius * Math.sin(angle);
                    
                    svg.append('text')
                        .attr('x', labelX)
                        .attr('y', labelY)
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .attr('class', 'axis-label')
                        .text(dim.name);
                });
                
                // Draw data polygon
                const dataPoints = config.dimensions.map((dim, i) => {
                    const angle = angleSlice * i - Math.PI / 2;
                    return [
                        rScale(dim.value) * Math.cos(angle),
                        rScale(dim.value) * Math.sin(angle)
                    ];
                });
                
                const line = d3.line()
                    .x(d => d[0])
                    .y(d => d[1])
                    .curve(d3.curveLinearClosed);
                
                svg.append('path')
                    .datum(dataPoints)
                    .attr('d', line)
                    .attr('fill', 'rgba(59, 130, 246, 0.3)')
                    .attr('stroke', '#3b82f6')
                    .attr('stroke-width', 2);
                
                // Add data points
                const tooltip = d3.select('#tooltip');
                svg.selectAll('.data-point')
                    .data(config.dimensions)
                    .enter().append('circle')
                    .attr('class', 'data-point')
                    .attr('cx', (d, i) => {
                        const angle = angleSlice * i - Math.PI / 2;
                        return rScale(d.value) * Math.cos(angle);
                    })
                    .attr('cy', (d, i) => {
                        const angle = angleSlice * i - Math.PI / 2;
                        return rScale(d.value) * Math.sin(angle);
                    })
                    .attr('r', 4)
                    .attr('fill', '#3b82f6')
                    .on('mouseover', (event, d) => {
                        tooltip.style('opacity', 1)
                            .html(`${d.name}: ${d.value}%`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 10) + 'px');
                    })
                    .on('mouseout', () => {
                        tooltip.style('opacity', 0);
                    });
            },
            
            // Placeholder renderer for N/A data
            renderPlaceholder(container, config) {
                const placeholder = container.append('div')
                    .attr('class', 'placeholder-container');
                
                placeholder.append('div')
                    .attr('class', 'placeholder-icon')
                    .text(config.icon || 'üìä');
                
                placeholder.append('div')
                    .attr('class', 'placeholder-message')
                    .text(config.message || 'Data Not Available');
                
                placeholder.append('div')
                    .attr('class', 'placeholder-description')
                    .text(config.description || 'No data currently available for this visualization.');
            }
        };
        
        // Render all charts
        document.addEventListener('DOMContentLoaded', () => {
            if (chartConfigs.health_trend) {
                ChartRenderer.renderHealthTrend('health-trend-chart', chartConfigs.health_trend);
            }
            
            if (chartConfigs.integration_heatmap) {
                ChartRenderer.renderIntegrationHeatmap('integration-heatmap', chartConfigs.integration_heatmap);
            }
            
            if (chartConfigs.test_coverage) {
                ChartRenderer.renderTestCoverageGauge('test-coverage-gauge', chartConfigs.test_coverage);
            }
            
            if (chartConfigs.code_quality) {
                ChartRenderer.renderCodeQualityRadar('code-quality-radar', chartConfigs.code_quality);
            }
        });
    </script>
</body>
</html>
