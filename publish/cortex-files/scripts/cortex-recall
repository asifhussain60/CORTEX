#!/usr/bin/env python3
"""
CORTEX Recall - Smart conversation history search

Semantic search across conversation history with natural language queries.

Usage:
    cortex-recall "last python change"
    cortex-recall "authentication feature"
    cortex-recall "bug fixes this week"
    cortex-recall --type feature --limit 10
    cortex-recall --format json

Author: Asif Hussain
Copyright: ¬© 2024-2025 Asif Hussain. All rights reserved.
Phase: Phase 4.2 - Shell Integration
"""

import sys
import os
import json
from pathlib import Path
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any
import argparse
import re

# Add CORTEX root to path
CORTEX_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(CORTEX_ROOT))

try:
    from src.tier1.working_memory import WorkingMemory
    from src.tier2.knowledge_graph import KnowledgeGraph
except ImportError as e:
    print(f"[ERROR] Failed to import CORTEX modules: {e}")
    sys.exit(1)


class ConversationRecall:
    """Smart conversation history search"""
    
    def __init__(self, repo_path: Optional[Path] = None):
        """Initialize recall system"""
        self.repo_path = repo_path or Path.cwd()
        self.brain_path = self.repo_path / "cortex-brain"
        
        if not self.brain_path.exists():
            print(f"[ERROR] CORTEX brain not found at: {self.brain_path}")
            sys.exit(1)
        
        self.tier1 = WorkingMemory(self.brain_path)
        self.tier2 = KnowledgeGraph(self.brain_path)
    
    def recall(self, query: str, 
               conv_type: Optional[str] = None,
               limit: int = 10,
               format_type: str = "short") -> List[Dict]:
        """
        Recall conversations matching query
        
        Args:
            query: Natural language search query
            conv_type: Filter by type (feature, bug, refactor, general)
            limit: Maximum results
            format_type: Output format (short, full, json)
        
        Returns:
            List of matching conversations
        """
        try:
            start_time = datetime.now()
            
            # Parse query for special patterns
            time_filter = self._parse_time_filter(query)
            keyword_query = self._extract_keywords(query)
            
            # Search in Tier 1
            results = self.tier1.search_conversations(
                keyword_query,
                limit=limit * 2  # Get more, will filter
            )
            
            # Apply filters
            filtered = self._apply_filters(
                results,
                conv_type=conv_type,
                time_filter=time_filter
            )
            
            # Limit results
            filtered = filtered[:limit]
            
            # Format output
            elapsed = (datetime.now() - start_time).total_seconds()
            
            if format_type == "json":
                self._print_json(filtered)
            elif format_type == "full":
                self._print_full(filtered, query, elapsed)
            else:
                self._print_short(filtered, query, elapsed)
            
            return filtered
            
        except Exception as e:
            print(f"‚ùå Recall failed: {e}")
            return []
    
    def _parse_time_filter(self, query: str) -> Optional[Dict]:
        """Parse time-based filters from query"""
        query_lower = query.lower()
        now = datetime.now()
        
        # Check for time keywords
        if "today" in query_lower:
            return {"start": now.replace(hour=0, minute=0, second=0)}
        elif "yesterday" in query_lower:
            yesterday = now - timedelta(days=1)
            return {
                "start": yesterday.replace(hour=0, minute=0, second=0),
                "end": yesterday.replace(hour=23, minute=59, second=59)
            }
        elif "this week" in query_lower or "last week" in query_lower:
            days = 7 if "this week" in query_lower else 14
            return {"start": now - timedelta(days=days)}
        elif "this month" in query_lower:
            return {"start": now - timedelta(days=30)}
        
        # Check for "last N" pattern
        last_match = re.search(r'last\s+(\d+)\s+(hour|day|week)', query_lower)
        if last_match:
            count = int(last_match.group(1))
            unit = last_match.group(2)
            
            if unit == "hour":
                return {"start": now - timedelta(hours=count)}
            elif unit == "day":
                return {"start": now - timedelta(days=count)}
            elif unit == "week":
                return {"start": now - timedelta(weeks=count)}
        
        return None
    
    def _extract_keywords(self, query: str) -> str:
        """Extract searchable keywords from natural language query"""
        # Remove common time-based phrases
        time_phrases = [
            "today", "yesterday", "this week", "last week",
            "this month", "last month", r"last\s+\d+\s+(hour|day|week)s?"
        ]
        
        cleaned = query
        for phrase in time_phrases:
            cleaned = re.sub(phrase, "", cleaned, flags=re.IGNORECASE)
        
        # Remove common words
        stop_words = ["the", "a", "an", "in", "on", "at", "to", "for", "of", "with"]
        words = cleaned.split()
        keywords = [w for w in words if w.lower() not in stop_words and len(w) > 2]
        
        return " ".join(keywords)
    
    def _apply_filters(self, results: List[Dict],
                      conv_type: Optional[str],
                      time_filter: Optional[Dict]) -> List[Dict]:
        """Apply filters to search results"""
        filtered = results
        
        # Type filter
        if conv_type and conv_type != "all":
            filtered = [
                r for r in filtered
                if r.get("metadata", {}).get("type") == conv_type
            ]
        
        # Time filter
        if time_filter:
            start = time_filter.get("start")
            end = time_filter.get("end")
            
            filtered = [
                r for r in filtered
                if self._in_time_range(r.get("timestamp"), start, end)
            ]
        
        return filtered
    
    def _in_time_range(self, timestamp: str,
                       start: Optional[datetime],
                       end: Optional[datetime]) -> bool:
        """Check if timestamp is in range"""
        try:
            dt = datetime.fromisoformat(timestamp)
            
            if start and dt < start:
                return False
            if end and dt > end:
                return False
            
            return True
        except:
            return True
    
    def _print_short(self, results: List[Dict], query: str, elapsed: float):
        """Print short format results"""
        if not results:
            print(f"üîç No results found for: {query}")
            print(f"   Try a different query or check spelling")
            return
        
        print(f"\n=== Found {len(results)} Results ({elapsed:.2f}s) ===\n")
        print(f"Query: {query}\n")
        
        for i, conv in enumerate(results, 1):
            timestamp = conv.get("timestamp", "Unknown")
            content = conv.get("content", "")
            conv_type = conv.get("metadata", {}).get("type", "general")
            
            # Format timestamp
            try:
                dt = datetime.fromisoformat(timestamp)
                time_str = dt.strftime("%m/%d %H:%M")
            except:
                time_str = timestamp[:16]
            
            # Truncate content
            if len(content) > 80:
                content = content[:77] + "..."
            
            # Print
            print(f"{i}. [{conv_type.upper():8}] {time_str} ‚îÇ {content}")
        
        print(f"\nüí° Tip: Use --format full for complete details")
    
    def _print_full(self, results: List[Dict], query: str, elapsed: float):
        """Print full format results"""
        if not results:
            print(f"üîç No results found for: {query}")
            return
        
        print(f"\n=== Found {len(results)} Results ({elapsed:.2f}s) ===\n")
        print(f"Query: {query}\n")
        print("=" * 70)
        
        for i, conv in enumerate(results, 1):
            timestamp = conv.get("timestamp", "Unknown")
            content = conv.get("content", "")
            conv_type = conv.get("metadata", {}).get("type", "general")
            conv_id = conv.get("id", "unknown")
            metadata = conv.get("metadata", {})
            
            # Format timestamp
            try:
                dt = datetime.fromisoformat(timestamp)
                time_str = dt.strftime("%Y-%m-%d %H:%M:%S")
            except:
                time_str = timestamp
            
            # Print
            print(f"\n{i}. [{conv_type.upper()}] {time_str}")
            print(f"   ID: {conv_id}")
            print(f"   Content: {content}")
            
            # Print tags if available
            if "tags" in metadata and metadata["tags"]:
                print(f"   Tags: {', '.join(metadata['tags'])}")
            
            # Print files if available
            if "changed_files" in metadata.get("context", {}):
                files = metadata["context"]["changed_files"]
                if files:
                    print(f"   Files: {len(files)} changed")
                    for f in files[:3]:
                        print(f"     - {f}")
                    if len(files) > 3:
                        print(f"     ... and {len(files) - 3} more")
        
        print("\n" + "=" * 70)
    
    def _print_json(self, results: List[Dict]):
        """Print JSON format results"""
        output = {
            "count": len(results),
            "results": results
        }
        print(json.dumps(output, indent=2, default=str))


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description="CORTEX Recall - Smart conversation history search",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  cortex-recall "last python change"
  cortex-recall "authentication feature" --type feature
  cortex-recall "bug fixes this week" --type bug
  cortex-recall "refactor" --limit 5 --format full
  cortex-recall "today" --format json

Natural language queries:
  - "today", "yesterday", "this week", "last week"
  - "last 3 days", "last 2 hours"
  - "python changes", "authentication feature"
  - "bug fixes", "refactoring work"
        """
    )
    
    parser.add_argument(
        "query",
        nargs="?",
        default="",
        help="Natural language search query"
    )
    
    parser.add_argument(
        "--type", "-t",
        choices=["feature", "bug", "refactor", "general", "all"],
        help="Filter by conversation type"
    )
    
    parser.add_argument(
        "--limit", "-l",
        type=int,
        default=10,
        help="Maximum results (default: 10)"
    )
    
    parser.add_argument(
        "--format", "-f",
        choices=["short", "full", "json"],
        default="short",
        help="Output format (default: short)"
    )
    
    parser.add_argument(
        "--repo",
        type=Path,
        help="Repository path (default: current directory)"
    )
    
    args = parser.parse_args()
    
    # Validate query
    if not args.query:
        parser.print_help()
        print("\n‚ùå Error: Query required")
        sys.exit(1)
    
    # Initialize
    try:
        recall = ConversationRecall(repo_path=args.repo)
    except Exception as e:
        print(f"[ERROR] Failed to initialize: {e}")
        sys.exit(1)
    
    # Execute recall
    results = recall.recall(
        args.query,
        conv_type=args.type,
        limit=args.limit,
        format_type=args.format
    )
    
    sys.exit(0 if results else 1)


if __name__ == "__main__":
    main()
