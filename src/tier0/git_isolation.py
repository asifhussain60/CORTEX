"""
CORTEX Git Isolation Enforcement
Prevents CORTEX source code from being committed to user application repositories.

This module:
1. Installs git hooks in user repos to block CORTEX code commits
2. Scans staged files for CORTEX paths
3. Provides clear error messages and alternatives

Author: Asif Hussain
Copyright: Â© 2024-2025 Asif Hussain. All rights reserved.
License: Proprietary - See LICENSE file
"""

from pathlib import Path
from typing import List, Tuple, Optional
import subprocess
import sys
import logging

logger = logging.getLogger(__name__)

# CORTEX paths that MUST NOT be committed to user repos
CORTEX_PROTECTED_PATHS = [
    "src/tier0/",
    "src/tier1/",
    "src/tier2/",
    "src/tier3/",
    "src/cortex_agents/",
    "src/plugins/",
    "src/crawlers/",
    "cortex-brain/",
    "prompts/",
    "scripts/cortex/",
    "CORTEX/",
]

# Allowed: Team knowledge sharing (exported YAML patterns)
CORTEX_ALLOWED_PATHS = [
    "team-knowledge/",
]


class GitIsolationEnforcer:
    """
    Enforces CORTEX code isolation from user application repositories.
    
    Responsibilities:
    - Install git hooks in user repos
    - Scan commits for CORTEX code
    - Block commits that violate isolation
    - Provide clear error messages
    """
    
    def __init__(self, user_repo_path: Path):
        """
        Initialize enforcer for a user repository.
        
        Args:
            user_repo_path: Path to user's application repository
        """
        self.user_repo_path = user_repo_path
        self.git_dir = user_repo_path / ".git"
        self.hooks_dir = self.git_dir / "hooks"
    
    def install_hooks(self) -> bool:
        """
        Install git hooks to prevent CORTEX code commits.
        
        Returns:
            True if hooks installed successfully
        """
        if not self.git_dir.exists():
            logger.error(f"Not a git repository: {self.user_repo_path}")
            return False
        
        # Create hooks directory if needed
        self.hooks_dir.mkdir(parents=True, exist_ok=True)
        
        # Install pre-commit hook
        pre_commit_installed = self._install_pre_commit_hook()
        
        # Install pre-push hook (extra safety)
        pre_push_installed = self._install_pre_push_hook()
        
        if pre_commit_installed and pre_push_installed:
            logger.info(f"âœ… Git isolation hooks installed in {self.user_repo_path}")
            return True
        else:
            logger.warning("âš ï¸ Some hooks failed to install")
            return False
    
    def _install_pre_commit_hook(self) -> bool:
        """
        Install pre-commit hook to scan staged files.
        
        Returns:
            True if installed successfully
        """
        hook_path = self.hooks_dir / "pre-commit"
        
        # Check if hook already exists
        if hook_path.exists():
            content = hook_path.read_text()
            if "CORTEX Git Isolation" in content:
                logger.info("Pre-commit hook already installed")
                return True
        
        # Generate hook script
        hook_script = self._generate_pre_commit_script()
        
        # Write hook
        hook_path.write_text(hook_script)
        
        # Make executable (Unix/Mac)
        if sys.platform != "win32":
            hook_path.chmod(0o755)
        
        logger.info(f"Installed pre-commit hook: {hook_path}")
        return True
    
    def _install_pre_push_hook(self) -> bool:
        """
        Install pre-push hook as final safety check.
        
        Returns:
            True if installed successfully
        """
        hook_path = self.hooks_dir / "pre-push"
        
        # Check if hook already exists
        if hook_path.exists():
            content = hook_path.read_text()
            if "CORTEX Git Isolation" in content:
                logger.info("Pre-push hook already installed")
                return True
        
        # Generate hook script
        hook_script = self._generate_pre_push_script()
        
        # Write hook
        hook_path.write_text(hook_script)
        
        # Make executable (Unix/Mac)
        if sys.platform != "win32":
            hook_path.chmod(0o755)
        
        logger.info(f"Installed pre-push hook: {hook_path}")
        return True
    
    def _generate_pre_commit_script(self) -> str:
        """
        Generate pre-commit hook script.
        
        Returns:
            Shell script content
        """
        protected_paths = "|".join(CORTEX_PROTECTED_PATHS).replace("/", "\\/")
        
        script = f"""#!/bin/sh
# CORTEX Git Isolation - Pre-Commit Hook
# Prevents CORTEX source code from being committed to user repositories
# Auto-generated by CORTEX setup process

echo "ğŸ” Checking for CORTEX code isolation violations..."

# Get list of staged files
STAGED_FILES=$(git diff --cached --name-only)

# CORTEX protected paths (regex)
PROTECTED_PATTERN="{protected_paths}"

# Check each staged file
VIOLATIONS=""
for FILE in $STAGED_FILES; do
    if echo "$FILE" | grep -E "$PROTECTED_PATTERN" > /dev/null; then
        # Exception: team-knowledge/ is allowed (exported YAML patterns)
        if echo "$FILE" | grep "^team-knowledge/" > /dev/null; then
            continue
        fi
        VIOLATIONS="$VIOLATIONS\\n  - $FILE"
    fi
done

# If violations found, block commit
if [ -n "$VIOLATIONS" ]; then
    echo ""
    echo "ğŸš¨ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸš¨ BLOCKED: CORTEX Git Isolation Violation"
    echo "ğŸš¨ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "The following CORTEX files are staged for commit:"
    echo "$VIOLATIONS"
    echo ""
    echo "âŒ CORTEX source code MUST NOT be committed to user repos!"
    echo ""
    echo "âœ… CORRECT SETUP:"
    echo "   - Keep CORTEX as separate repository/package"
    echo "   - User repo: Application code only"
    echo "   - CORTEX repo: Framework code (separate)"
    echo "   - Knowledge sharing: team-knowledge/ directory (YAML exports)"
    echo ""
    echo "ğŸ“š Documentation: cortex-brain/brain-protection-rules.yaml"
    echo "   Rule: GIT_ISOLATION_ENFORCEMENT (Tier 0 Instinct)"
    echo ""
    exit 1
fi

echo "âœ… No CORTEX code detected. Commit allowed."
exit 0
"""
        return script
    
    def _generate_pre_push_script(self) -> str:
        """
        Generate pre-push hook script (final safety check).
        
        Returns:
            Shell script content
        """
        protected_paths = "|".join(CORTEX_PROTECTED_PATHS).replace("/", "\\/")
        
        script = f"""#!/bin/sh
# CORTEX Git Isolation - Pre-Push Hook
# Final safety check before pushing to remote
# Auto-generated by CORTEX setup process

echo "ğŸ” Final CORTEX isolation check before push..."

# Get list of files in last commit
COMMITTED_FILES=$(git diff --name-only HEAD~1 HEAD)

# CORTEX protected paths (regex)
PROTECTED_PATTERN="{protected_paths}"

# Check each file
VIOLATIONS=""
for FILE in $COMMITTED_FILES; do
    if echo "$FILE" | grep -E "$PROTECTED_PATTERN" > /dev/null; then
        # Exception: team-knowledge/ is allowed
        if echo "$FILE" | grep "^team-knowledge/" > /dev/null; then
            continue
        fi
        VIOLATIONS="$VIOLATIONS\\n  - $FILE"
    fi
done

# If violations found, block push
if [ -n "$VIOLATIONS" ]; then
    echo ""
    echo "ğŸš¨ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸš¨ BLOCKED: CORTEX Code About to Be Pushed!"
    echo "ğŸš¨ â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "CORTEX files detected in push:"
    echo "$VIOLATIONS"
    echo ""
    echo "âŒ This would expose CORTEX source code to user repository!"
    echo ""
    echo "ğŸ”§ FIX OPTIONS:"
    echo "   1. Revert the commit: git reset HEAD~1"
    echo "   2. Remove CORTEX files: git rm --cached <files>"
    echo "   3. Amend commit without CORTEX files"
    echo ""
    echo "ğŸ“š Rule: GIT_ISOLATION_ENFORCEMENT (Tier 0 Instinct)"
    echo ""
    exit 1
fi

echo "âœ… No CORTEX code in push. Safe to proceed."
exit 0
"""
        return script
    
    def check_staged_files(self) -> Tuple[bool, List[str]]:
        """
        Check if any staged files contain CORTEX code.
        
        Returns:
            (is_safe, violations) where is_safe=False if violations found
        """
        try:
            # Get staged files
            result = subprocess.run(
                ["git", "diff", "--cached", "--name-only"],
                cwd=self.user_repo_path,
                capture_output=True,
                text=True,
                check=True
            )
            
            staged_files = result.stdout.strip().split("\n")
            violations = []
            
            for file_path in staged_files:
                if not file_path:
                    continue
                
                # Check if file matches CORTEX protected paths
                if self._is_cortex_path(file_path):
                    # Exception: team-knowledge/ allowed
                    if not file_path.startswith("team-knowledge/"):
                        violations.append(file_path)
            
            return (len(violations) == 0, violations)
        
        except subprocess.CalledProcessError as e:
            logger.error(f"Failed to check staged files: {e}")
            return (True, [])  # Fail open (don't block if git command fails)
    
    def _is_cortex_path(self, file_path: str) -> bool:
        """
        Check if file path matches CORTEX protected paths.
        
        Args:
            file_path: Relative file path
            
        Returns:
            True if path is protected CORTEX code
        """
        for protected_path in CORTEX_PROTECTED_PATHS:
            if protected_path in file_path:
                return True
        return False
    
    def uninstall_hooks(self) -> bool:
        """
        Remove CORTEX git hooks (for testing or uninstall).
        
        Returns:
            True if hooks removed successfully
        """
        hooks_removed = False
        
        for hook_name in ["pre-commit", "pre-push"]:
            hook_path = self.hooks_dir / hook_name
            if hook_path.exists():
                content = hook_path.read_text()
                if "CORTEX Git Isolation" in content:
                    hook_path.unlink()
                    logger.info(f"Removed {hook_name} hook")
                    hooks_removed = True
        
        return hooks_removed


def install_git_isolation_hooks(user_repo_path: Path) -> bool:
    """
    Install git hooks to enforce CORTEX isolation.
    
    This is called during 'cortex init' setup process.
    
    Args:
        user_repo_path: Path to user's application repository
        
    Returns:
        True if hooks installed successfully
    """
    enforcer = GitIsolationEnforcer(user_repo_path)
    return enforcer.install_hooks()


def check_git_isolation(user_repo_path: Path) -> Tuple[bool, List[str]]:
    """
    Check if staged files violate git isolation.
    
    Args:
        user_repo_path: Path to user's application repository
        
    Returns:
        (is_safe, violations) tuple
    """
    enforcer = GitIsolationEnforcer(user_repo_path)
    return enforcer.check_staged_files()
